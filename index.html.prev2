<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Topic News Aggregator</title>
    <meta name="theme-color" content="#111827" />
    <link rel="manifest" href="./manifest.webmanifest" />
    <link rel="icon" href="./icons/icon-192.png" />
    <style>
      html,body { height: 100%; margin: 0; }
      #root { min-height: 100vh; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      .source-pill{ display:inline-flex; align-items:center; gap:.35rem; padding:.15rem .5rem; border-radius:9999px; background:#0b1220; color:#93c5fd; border:1px solid #1f2937; font-size:12px }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useMemo, useEffect } = React;

      /**
       * Advanced Google News link decoder with multiple strategies
       * @param {string} link - The Google News wrapped link
       * @returns {string} - The decoded original URL or the input if not decodable
       */
      function decodeGoogleLink(link) {
        try {
          if (!link) return link;
          
          // Enhanced Google domain detection - be more aggressive
          if (!/google\.|news\.google|googleusercontent|google-proxy/.test(link)) return link;
          
          console.log('üîç Attempting to decode Google News link:', link);
          
          const url = new URL(link);
          
          // Strategy 1: Extract from /articles/ path with base64 decoding
          const articleMatch = url.pathname.match(/\/articles\/([A-Za-z0-9\-_=]+)/);
          if (articleMatch) {
            try {
              let encoded = articleMatch[1];
              // Handle URL-safe base64
              encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');
              while (encoded.length % 4) encoded += '=';
              
              const decoded = atob(encoded);
              console.log('üìù Base64 decoded content:', decoded);
              
              // Multiple patterns to find URLs in the decoded content
              const patterns = [
                /https?:\/\/[^\s\x00-\x1f"'<>]+/g,
                /\x08\x13\x22(https?:\/\/[^\x00-\x1f"'<>]+)/g,
                /CBM[a-zA-Z0-9]+(https?:\/\/[^\x00-\x1f"'<>]+)/g
              ];
              
              for (const pattern of patterns) {
                const matches = decoded.match(pattern);
                if (matches) {
                  for (const match of matches) {
                    const cleanUrl = match.replace(/[\x00-\x1f]+/g, '').trim();
                    if (cleanUrl.startsWith('http') && !cleanUrl.includes('google.') && cleanUrl.length > 15) {
                      console.log('‚úÖ Successfully decoded from base64:', cleanUrl);
                      return cleanUrl;
                    }
                  }
                }
              }
            } catch (e) {
              console.warn('‚ùå Base64 decode failed:', e);
            }
          }
          
          // Strategy 2: Extract from query parameters (enhanced)
          const queryParams = ['url', 'u', 'q', 'link', 'target', 'dest', 'redirect'];
          for (const param of queryParams) {
            const value = url.searchParams.get(param);
            if (value) {
              try {
                const decoded = decodeURIComponent(value);
                if (decoded.startsWith('http') && !decoded.includes('google.')) {
                  console.log('‚úÖ Successfully decoded from query param:', decoded);
                  return decoded;
                }
              } catch (e) {
                console.warn('‚ùå Query param decode failed:', e);
              }
            }
          }
          
          // Strategy 3: Extract embedded URLs from the full URL
          const fullUrl = decodeURIComponent(link);
          const embeddedMatches = fullUrl.match(/https?:\/\/(?!.*google\.)[^\s&"'<>]+/g);
          if (embeddedMatches) {
            for (const match of embeddedMatches) {
              if (match.length > 15 && !match.includes('google.')) {
                console.log('‚úÖ Successfully extracted embedded URL:', match);
                return match;
              }
            }
          }
          
          // Strategy 4: Try to resolve the redirect by checking if it's a redirect URL
          if (url.pathname.includes('/url')) {
            const redirectUrl = url.searchParams.get('q') || url.searchParams.get('url');
            if (redirectUrl && redirectUrl.startsWith('http')) {
              console.log('‚úÖ Found redirect URL:', redirectUrl);
              return redirectUrl;
            }
          }
          
          console.log('‚ö†Ô∏è Could not decode Google News link, returning original');
          return link;
          
        } catch (err) {
          console.warn('‚ùå Google News decode error:', err);
          return link;
        }
      }

      // List of major Israeli news domains used to scope Google News RSS queries for Hebrew topics.
      // Expanded to include additional free-to-read sources beyond the traditional outlets. These
      // domains correspond to sites that generally do not require a subscription to read the
      // latest headlines. When modifying this list, ensure that each site is accessible
      // without paywalls.
      const IL_SITES = [
        "ynet.co.il",     // Ynet (Yedioth Ahronoth)
        "walla.co.il",    // Walla! News
        "haaretz.co.il",  // Haaretz (Hebrew)
        "israelhayom.co.il", // Israel Hayom
        "maariv.co.il",   // Maariv
        "globes.co.il",   // Globes
        "themarker.com",  // TheMarker
        "n12.co.il",      // Channel 12 News (Mako)
        "kan.org.il"      // Kan 11 (Israeli Public Broadcasting)
      ];

      function heVariants(q){
        const vars = new Set([q]);
        if (q.includes("◊§◊ô◊ë◊®◊ï◊û◊ô◊ú◊ê◊í◊ô◊î")) vars.add("◊§◊ô◊ë◊®◊ï◊û◊ô◊ê◊ú◊í◊ô◊î");
        vars.add(q.replace(/◊ô◊ú◊ê◊í◊ô◊î/g, "◊ô◊ê◊ú◊í◊ô◊î"));
        return Array.from(vars).filter(Boolean);
      }

      function App() {
        const [topic, setTopic] = useState("");
        const [articles, setArticles] = useState([]);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);
        const [sort, setSort] = useState("relevance");
        const [menuOpen, setMenuOpen] = useState(false);
        const [history, setHistory] = useState([]);
        const [selected, setSelected] = useState(new Set());
        const [preview, setPreview] = useState(null);
        const [scanInfo, setScanInfo] = useState({attempted:0, succeeded:0});

        const isHebrewUI = useMemo(() => /[\u0590-\u05FF]/.test(topic), [topic]);

        useEffect(() => {
          const saved = JSON.parse(localStorage.getItem("news_topics_history") || "[]");
          if (Array.isArray(saved)) setHistory(saved);
          const last = localStorage.getItem("news_last_topic");
          if (last) setTopic(last);
          if ("serviceWorker" in navigator) {
            // Always append a version parameter to the service worker URL so that
            // browsers fetch the latest worker when the app is deployed. The
            // version should align with the CACHE constant in sw.js.
            navigator.serviceWorker.register("./sw.js?v=5")
              .then(() => console.log('Service worker registered'))
              .catch(err => console.warn('Service worker registration failed:', err));
          }
        }, []);

        useEffect(() => { localStorage.setItem("news_last_topic", topic); }, [topic]);
        useEffect(() => { localStorage.setItem("news_topics_history", JSON.stringify(history)); }, [history]);

        function timeAgo(iso) {
          if (!iso) return "";
          const t = Date.now() - new Date(iso).getTime();
          const m = Math.max(0, Math.floor(t/60000));
          if (m < 1) return isHebrewUI ? "◊¢◊õ◊©◊ô◊ï" : "just now";
          if (m < 60) return isHebrewUI ? `${m} ◊ì◊ß` : `${m}m`;
          const h = Math.floor(m/60);
          if (h < 24) return isHebrewUI ? `${h} ◊©◊≥` : `${h}h`;
          const d = Math.floor(h/24);
          return isHebrewUI ? `${d} ◊ô◊û◊ô◊ù` : `${d}d`;
        }

        function truncate(s, n=160) { return !s ? "" : (s.length > n ? s.slice(0,n-1) + "‚Ä¶" : s); }
        const fallbackImgSeed = (title) => `https://picsum.photos/seed/${encodeURIComponent(title||"news")}/900/600`;

        function normalizeAndSort(arr, qForRelevance) {
          const list = [...arr];
          if (sort === "newest") return list.sort((a,b)=> new Date(b.publishedAt||0) - new Date(a.publishedAt||0));
          if (sort === "oldest") return list.sort((a,b)=> new Date(a.publishedAt||0) - new Date(b.publishedAt||0));
          const q = (qForRelevance||"").toLowerCase();
          return list.sort((a,b)=>{
            const inA = (a.title||"").toLowerCase().includes(q)?1:0;
            const inB = (b.title||"").toLowerCase().includes(q)?1:0;
            const tA = new Date(a.publishedAt||0).getTime();
            const tB = new Date(b.publishedAt||0).getTime();
            const sA = a.score||0, sB = b.score||0;
            return (inB*2 + tB/1e13 + sB/1000) - (inA*2 + tA/1e13 + sA/1000);
          });
        }

        function addToHistory(q){ if (!q) return; setHistory(prev=>[q, ...prev.filter(x=>x!==q)].slice(0,50)); }

  // Google News RSS removed. Only direct/free sources are used.
        async function fetchRSS(url){
          // Try multiple CORS proxies for better reliability
          const proxies = [
            // Most reliable proxies first
            `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
            `https://corsproxy.io/?${encodeURIComponent(url)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
            // Additional backup proxies  
            `https://cors.bridged.cc/https://${url.replace(/^https?:\/\//, '')}`,
            `https://proxy.cors.sh/${url}`,
            `https://thingproxy.freeboard.io/fetch/${url}`
          ];
          
          console.log('üîÑ Attempting to fetch RSS from:', url);
          
          for (let i = 0; i < proxies.length; i++) {
            try {
              const proxy = proxies[i];
              console.log(`üì° Trying proxy ${i+1}/${proxies.length}:`, proxy.split('?')[0]);
              
              // Add timeout to prevent hanging requests
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
              
              const r = await fetch(proxy, {
                headers: {
                  'X-Requested-With': 'XMLHttpRequest',
                  'User-Agent': 'Mozilla/5.0 (compatible; NewsAgg/1.0)'
                },
                mode: 'cors',
                signal: controller.signal
              });
              
              clearTimeout(timeoutId);
              
              if (!r.ok) {
                console.warn(`‚ùå Proxy ${i+1} returned status ${r.status}: ${r.statusText}`);
                continue;
              }
              
              let xmlContent;
              if (proxy.includes('allorigins.win')) {
                const j = await r.json();
                xmlContent = j.contents || "";
              } else if (proxy.includes('codetabs.com')) {
                const j = await r.json();
                xmlContent = j.data || "";
              } else {
                xmlContent = await r.text();
              }
              
              if (!xmlContent || xmlContent.length < 50) {
                console.warn(`‚ùå Proxy ${i+1} returned empty/small content`);
                continue;
              }
              
              console.log(`‚úÖ Proxy ${i+1} succeeded, parsing XML...`);
              
              const xml = new DOMParser().parseFromString(xmlContent, "text/xml");
              
              // Check if XML parsing was successful
              const parseError = xml.querySelector('parsererror');
              if (parseError) {
                console.warn(`‚ùå XML parsing failed for proxy ${i+1}`);
                continue;
              }
              
              const items = Array.from(xml.querySelectorAll("item")).map((node, idx)=>{
                const title = node.querySelector("title")?.textContent || "";
                const link = node.querySelector("link")?.textContent || "";
                
                console.log(`üîó Processing article: "${title.substring(0, 50)}..." | Link: ${link}`);
                
                // Enhanced Google News link decoding
                const decodedLink = decodeGoogleLink(link);
                
                if (decodedLink !== link) {
                  console.log(`‚úÖ Successfully decoded Google News link: ${decodedLink}`);
                } else if (link.includes('google.')) {
                  console.warn(`‚ö†Ô∏è Could not decode Google News link: ${link}`);
                }
                
                const pubDate = node.querySelector("pubDate")?.textContent || "";
                
                // Determine source from decoded link for better accuracy
                let source = node.querySelector("source")?.textContent?.trim() || "";
                if (!source) {
                  try {
                    const urlObj = new URL(decodedLink); // Use decoded link for source detection
                    source = urlObj.hostname.replace(/^www\./, '');
                  } catch (e) {
                    try {
                      const urlObj = new URL(link); // Fallback to original link
                      source = urlObj.hostname.replace(/^www\./, '');
                    } catch (e2) {
                      source = "Unknown";
                    }
                  }
                }
                
                const description = node.querySelector("description")?.textContent || "";
                // Don't use Google News thumbnail images - we'll fetch the real ones later
                const image = fallbackImgSeed(title);
                return { 
                  id:`gn_${idx}_${decodedLink}`, 
                  title, 
                  url: decodedLink, 
                  originalUrl: link, // Keep track of original URL for comparison
                  source, 
                  publishedAt:new Date(pubDate).toISOString(), 
                  description: description.replace(/<[^>]+>/g, ''), 
                  image, 
                  needsImageFetch: true, // Flag to indicate we need to fetch the real image
                  score:0 
                };
              });
              
              console.log(`üìä Successfully extracted ${items.length} articles from RSS`);
              
              // If we got items successfully, return them
              if (items.length > 0) {
                return items;
              }
            } catch(e) {
              console.warn(`‚ùå Proxy ${i+1} failed with error:`, e.message);
              // Continue to next proxy
            }
          }
          
          // If all proxies failed, return empty array
          console.error('üí• All RSS proxies failed for URL:', url);
          return [];
        }

        async function fetchNews(query){
          const q = (query ?? topic).trim();
          if (!q) return;
          setLoading(true); setError(null); setArticles([]);
          setScanInfo({attempted:0, succeeded:0});
          try {
            const isHeb = /[\u0590-\u05FF]/.test(q);
            const variants = isHeb ? heVariants(q) : [q];
            const endpoints = [];
            
            // Add direct RSS feeds from MULTI_SOURCES instead of Google News
            console.log('üì° Adding direct RSS sources...');
            
            // Add all direct RSS sources from MULTI_SOURCES
            const directSources = [
              "https://www.reuters.com/rss/world",
              "https://www.ynet.co.il/Integration/StoryRss2.xml",
              "https://www.walla.co.il/rss/1",
              "https://www.globes.co.il/webservice/rss/rssfeeder.asmx/FrontPage",
              "https://rcs.mako.co.il/rss/news-israel.xml",
              "https://www.timesofisrael.com/feed/",
              "https://www.jpost.com/Rss/RssFeedsHeadlines.aspx",
              "https://www.haaretz.com/cmlink/haaretz-com-all-headlines-rss-1.4605102"
            ];
            
            endpoints.push(...directSources);
            
            console.log('üöÄ Using', endpoints.length, 'direct RSS sources');
            
            // Add Google News RSS as additional sources to improve coverage/reliability
            const gnewsBase = 'https://news.google.com/rss/search?';
            const gnews = [
              `${gnewsBase}q=${encodeURIComponent(q)}&hl=iw&gl=IL&ceid=IL:iw`,
              `${gnewsBase}q=${encodeURIComponent(q)}&hl=en-US&gl=US&ceid=US:en`
            ];
            // Scope Google News to Israeli domains as well
            const scoped = IL_SITES.slice(0, 10).map(dom => `${gnewsBase}q=${encodeURIComponent(`site:${dom} ${q}`)}&hl=iw&gl=IL&ceid=IL:iw`);
            endpoints.push(...gnews, ...scoped);
            console.log('‚ûï Added Google News RSS endpoints for reliability');

            setScanInfo({attempted:endpoints.length, succeeded:0});
            console.log('üöÄ Starting news fetch with', endpoints.length, 'endpoints');
            const results = await Promise.all(endpoints.map(fetchRSS));
            const succeeded = results.filter(arr => Array.isArray(arr) && arr.length>0).length;
            setScanInfo({attempted:endpoints.length, succeeded});
            console.log('üìä RSS fetch results:', succeeded, 'of', endpoints.length, 'succeeded');
            
            let merged = [];
            const seen = new Set();
            
            for (const arr of results) {
              for (const it of arr) {
                const key = (it.url || '') + '|' + (it.title || '').toLowerCase();
                if (!seen.has(key)) {
                  seen.add(key);
                  merged.push(it);
                }
              }
            }
            
            // If no results from RSS feeds due to proxy failures
            if (succeeded === 0 && q.trim()) {
              console.warn('All direct RSS proxies failed; keeping error only if subsequent parsing still yields zero.');
              console.error('‚ùå All CORS proxies failed to fetch RSS feeds');
              setError(`Unable to fetch news feeds. All proxy services are currently unavailable. Please try again later.`);
              setArticles([]);
              setLoading(false);
              // return;
            }
            
            // If no articles found despite successful RSS fetches
            if (merged.length === 0 && succeeded > 0) {
              setError(`No articles found for "${q}". Try a different search term.`);
              setArticles([]);
              setLoading(false);
              // return;
            }
            
            console.log('üîó Total articles before filtering:', merged.length);
            // Filter out results that do not include the exact query phrase (or its Hebrew
            // morphological variants) in the title or description. We avoid partial word matches
            // so that each result contains the full searched-for phrase. We normalise the
            // combined title/description by lowercasing and replacing HTML non-breaking spaces
            // with regular spaces before checking for inclusion.
            const lowerVariants = variants.map(t => String(t).toLowerCase()).filter(Boolean);
            const filtered = merged.filter(item => {
              let hay = ((item.title || '') + ' ' + (item.description || '')).toLowerCase();
              // normalise non-breaking spaces and HTML entities.
              // decode &nbsp; as well as plain 'nbsp' residue that may remain after stripping tags.
              hay = hay.replace(/&nbsp;|nbsp;|nbsp/gi, ' ').replace(/\u00a0/g, ' ');
              return lowerVariants.some(v => hay.includes(v));
            });
            
            
            // üîÑ Fallback: if strict filtering yields zero results, relax to show recent headlines
            // This avoids the "no results" scenario when sources don't include the exact phrase.
            let finalFiltered = filtered;
            if (finalFiltered.length === 0) {
              console.warn('‚ö†Ô∏è No items matched the exact phrase; falling back to unfiltered merged list.');
              finalFiltered = merged.slice(0, 100);
            }
// Count how many links were successfully decoded
            const decodedCount = finalFiltered.filter(item => item.url !== item.originalUrl).length;
            console.log('üì∞ Successfully decoded', decodedCount, 'Google News links out of', finalFiltered.length, 'total articles');
            
            setArticles(normalizeAndSort(filtered, q));
            addToHistory(q);

            // After the initial setArticles call, attempt to fetch original images
            // and enhanced content from the actual article pages. This is done
            // asynchronously so that results display quickly with fallback
            // images and update once the fetch completes.
            const maxContentFetch = 15; // limit to first 15 articles to balance performance
            const articlesToUpdate = filtered.slice(0, maxContentFetch);
            
            // Enhanced function to fetch original article images and metadata
            async function getOriginalArticleData(targetUrl){
              try{
                // Skip fetching if the target domain is a Google News wrapper
                try {
                  const host = new URL(targetUrl).hostname;
                  if (/\.google\./.test(host)) return null;
                } catch(_){ return null; }
                
                console.log('üñºÔ∏è Fetching original content for:', targetUrl);
                
                const proxies = [
                  `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
                  `https://api.allorigins.win/get?url=${encodeURIComponent(targetUrl)}`,
                  `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(targetUrl)}`
                ];
                
                for (const proxy of proxies) {
                  try {
                    const res = await fetch(proxy);
                    if(!res.ok) continue;
                    
                    let html;
                    if (proxy.includes('allorigins.win')) {
                      const data = await res.json();
                      html = String(data.contents || '');
                    } else if (proxy.includes('codetabs.com')) {
                      const data = await res.json();
                      html = String(data.data || '');
                    } else {
                      html = await res.text();
                    }
                    
                    if (!html || html.length < 100) continue;
                    
                    const doc = new DOMParser().parseFromString(html, 'text/html');
                    
                    // Multiple strategies to find the best image
                    let image = null;
                    
                    // Strategy 1: Open Graph image
                    image = doc.querySelector('meta[property="og:image"]')?.getAttribute('content');
                    
                    // Strategy 2: Twitter card image
                    if (!image) {
                      image = doc.querySelector('meta[name="twitter:image"]')?.getAttribute('content');
                    }
                    
                    // Strategy 3: Article images
                    if (!image) {
                      const articleImages = doc.querySelectorAll('article img, .article img, .content img, .post img');
                      for (const img of articleImages) {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        if (src && !src.includes('logo') && !src.includes('icon')) {
                          image = src;
                          break;
                        }
                      }
                    }
                    
                    // Strategy 4: Any large image
                    if (!image) {
                      const allImages = doc.querySelectorAll('img');
                      for (const img of allImages) {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        const width = parseInt(img.getAttribute('width') || '0');
                        const height = parseInt(img.getAttribute('height') || '0');
                        if (src && (width > 200 || height > 200) && !src.includes('logo') && !src.includes('icon')) {
                          image = src;
                          break;
                        }
                      }
                    }
                    
                    // Convert relative URLs to absolute
                    if (image && !image.startsWith('http')) {
                      try {
                        const baseUrl = new URL(targetUrl);
                        image = new URL(image, baseUrl.origin).toString();
                      } catch(e) {
                        console.warn('Failed to resolve relative image URL:', image);
                      }
                    }
                    
                    // Also get enhanced title and description
                    const enhancedTitle = doc.querySelector('meta[property="og:title"]')?.getAttribute('content') ||
                                        doc.querySelector('meta[name="twitter:title"]')?.getAttribute('content') ||
                                        doc.querySelector('title')?.textContent?.trim();
                                        
                    const enhancedDescription = doc.querySelector('meta[property="og:description"]')?.getAttribute('content') ||
                                              doc.querySelector('meta[name="description"]')?.getAttribute('content') ||
                                              doc.querySelector('meta[name="twitter:description"]')?.getAttribute('content');
                    
                    if (image || enhancedTitle || enhancedDescription) {
                      console.log('‚úÖ Found original content:', { image, enhancedTitle, enhancedDescription });
                      return { image, enhancedTitle, enhancedDescription };
                    }
                  } catch(proxyError) {
                    console.warn('‚ùå Proxy failed:', proxyError);
                    continue;
                  }
                }
                return null;
              } catch(err){
                console.warn('‚ùå Original content fetch failed:', err);
                return null;
              }
            }
            
            // Kick off enhanced content fetches in parallel but update state when done.
            Promise.all(articlesToUpdate.map(async (item) => {
              // Only fetch if we have a valid decoded URL and it's not a Google link
              if (item.url && !item.url.includes('google.') && item.needsImageFetch) {
                const originalContent = await getOriginalArticleData(item.url);
                if (originalContent) {
                  if (originalContent.image) {
                    item.image = originalContent.image;
                  }
                  if (originalContent.enhancedTitle && originalContent.enhancedTitle.length > item.title.length) {
                    item.enhancedTitle = originalContent.enhancedTitle;
                  }
                  if (originalContent.enhancedDescription && originalContent.enhancedDescription.length > item.description.length) {
                    item.enhancedDescription = originalContent.enhancedDescription;
                  }
                }
              }
              return item;
            })).then((updatedItems) => {
              // Merge the updated items back into the full list
              const updatedMap = new Map(updatedItems.map(it => [it.url, it]));
              const finalList = filtered.map(it => updatedMap.get(it.url) || it);
              console.log('üì∏ Updated articles with original content');
              setArticles(normalizeAndSort(finalList, q));
            }).catch(err => {
              console.warn('Some content fetches failed:', err);
              // Don't block the UI if some fetches fail
            });
          } catch (e){ setError(e?.message || 'Failed to fetch'); }
          finally { setLoading(false); }
        }

        function reSearch(q){ setTopic(q); setMenuOpen(false); setSelected(new Set()); fetchNews(q); }
        function toggleSelect(q){ setSelected(prev=>{ const n=new Set(prev); n.has(q)?n.delete(q):n.add(q); return n;}); }
        function deleteSelected(){ if (selected.size===0) return; setHistory(prev=>prev.filter(x=>!selected.has(x))); setSelected(new Set()); }
        function clearAll(){ setHistory([]); setSelected(new Set()); }

        async function openPreview(url, title, source, image){
          // Multiple layers of Google News URL decoding to ensure we get the direct link
          let initialUrl = url;
          
          // Apply multiple rounds of decoding in case of nested encoding
          for (let i = 0; i < 3; i++) {
            const decoded = decodeGoogleLink(initialUrl);
            if (decoded === initialUrl) break; // No more decoding possible
            initialUrl = decoded;
          }
          
          // Final check - if still contains google., try to extract any embedded URLs
          if (initialUrl.includes('google.')) {
            console.warn('üö® URL still contains Google after decoding:', initialUrl);
            // Try to extract any embedded non-Google URLs
            const embeddedMatches = initialUrl.match(/https?:\/\/(?!.*google\.)[^\s&"'<>]+/g);
            if (embeddedMatches && embeddedMatches.length > 0) {
              initialUrl = embeddedMatches[0];
              console.log('üîß Extracted embedded URL:', initialUrl);
            }
          }
          
          console.log('üéØ Final decoded URL for preview:', initialUrl);
          setPreview({ url: initialUrl, source, title, image, loading:true });
          
          try{
            const proxies = [
              `https://corsproxy.io/?${encodeURIComponent(initialUrl)}`,
              `https://api.allorigins.win/get?url=${encodeURIComponent(initialUrl)}`,
              `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(initialUrl)}`
            ];
            
            let html = '';
            let success = false;
            
            for (const proxy of proxies) {
              try {
                const res = await fetch(proxy);
                if (!res.ok) continue;
                
                if (proxy.includes('allorigins.win')) {
                  const data = await res.json();
                  html = String(data.contents || '');
                } else if (proxy.includes('codetabs.com')) {
                  const data = await res.json();
                  html = String(data.data || '');
                } else {
                  html = await res.text();
                }
                
                if (html.length > 0) {
                  success = true;
                  break;
                }
              } catch (proxyError) {
                // Try next proxy
                continue;
              }
            }
            
            if (!success) throw new Error('All proxies failed');
            
            const doc = new DOMParser().parseFromString(html,'text/html');
            const sel = q => doc.querySelector(q)?.getAttribute('content');
            const text = q => doc.querySelector(q)?.textContent;
            const mTitle = sel('meta[property="og:title"]') || sel('meta[name="twitter:title"]') || text('title') || title;
            const mDesc = sel('meta[property="og:description"]') || sel('meta[name="description"]') || sel('meta[name="twitter:description"]') || text('article p') || '';
            const mImg = sel('meta[property="og:image"]') || sel('meta[name="twitter:image"]') || image;
            // Prefer a canonical link or og:url from the fetched page. Many Google News links
            // redirect to an aggregator page; extracting the canonical or og:url provides
            // the original article link so that the "Read on site" button opens the
            // correct source rather than Google News. Fall back to the original URL
            // passed into openPreview if none is found.
            const canonical = doc.querySelector('link[rel="canonical"]')?.getAttribute('href')
              || sel('meta[property="og:url"]')
              || url;
            // Decode the canonical URL if it still points to a Google News wrapper
            const finalPreviewUrl = decodeGoogleLink(canonical);
            setPreview({ url: finalPreviewUrl, source, title: mTitle, description: mDesc, image: mImg, loading:false });
        } catch(e){ setPreview({ url: initialUrl, source, title, image, loading:false, error: e?.message || 'Preview failed' }); }
        }
        function closePreview(){ setPreview(null); }

        return (
          <div style={{ minHeight:'100vh', background:'linear-gradient(135deg, #0ea5e9 0%, #7c3aed 50%, #111827 100%)' }} dir={isHebrewUI?'rtl':'ltr'}>
            <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', padding:'12px 16px' }}>
              <button onClick={()=>setMenuOpen(v=>!v)} style={{ border:'1px solid #93c5fd', background:'rgba(17,24,39,0.6)', color:'#e5e7eb', borderRadius:10, padding:'8px 10px', cursor:'pointer' }}>‚ò∞</button>
              <h1 style={{ margin:0, fontSize:'1.6rem', color:'#fff' }}>{isHebrewUI ? '◊ê◊í◊®◊í◊ò◊ï◊® ◊ó◊ì◊©◊ï◊™ ◊ú◊§◊ô ◊†◊ï◊©◊ê' : 'Topic News Aggregator'}</h1>
              <div style={{ display:'flex', alignItems:'center', gap:8 }}>
                <label style={{ color:'#e5e7eb', fontSize:12 }}>{isHebrewUI ? '◊û◊ô◊ï◊ü' : 'Sort'}</label>
                <select value={sort} onChange={e=>setSort(e.target.value)} style={{ padding:'8px 10px', borderRadius:10, border:'1px solid #93c5fd', background:'#1f2937', color:'#f9fafb' }}>
                  <option value="relevance">{isHebrewUI ? '◊®◊ú◊ï◊ï◊†◊ò◊ô◊ï◊™' : 'Relevance'}</option>
                  <option value="newest">{isHebrewUI ? '◊ó◊ì◊© ◊™◊ó◊ô◊ú◊î' : 'Newest'}</option>
                  <option value="oldest">{isHebrewUI ? '◊ô◊©◊ü ◊™◊ó◊ô◊ú◊î' : 'Oldest'}</option>
                </select>
              </div>
            </div>

            <div style={{ display:'flex', alignItems:'center', gap:8, padding:'0 16px 8px', color:'#e5e7eb', fontSize:13 }}>
              <span class="source-pill">üîé {isHebrewUI ? '◊û◊ß◊ï◊®◊ï◊™ ◊©◊†◊°◊®◊ß◊ï' : 'Sources scanned'}: {scanInfo.succeeded}/{scanInfo.attempted}</span>
              <span class="source-pill">üáÆüá± IL: Direct RSS</span>
              <span class="source-pill">üåç International: Direct RSS</span>
              <span class="source-pill">üì∞ {isHebrewUI ? '◊ß◊ô◊©◊ï◊®◊ô◊ù ◊ô◊©◊ô◊®◊ô◊ù' : 'Direct links'}</span>
            </div>

            <aside style={{ position:'fixed', top:0, bottom:0, [isHebrewUI ? 'right' : 'left']:0, width: menuOpen ? 300 : 0, overflow:'hidden', background:'#0b1220', color:'#e5e7eb', borderLeft: isHebrewUI ? '1px solid #1f2937' : 'none', borderRight: !isHebrewUI ? '1px solid #1f2937' : 'none', transition:'width .2s ease', zIndex:50 }}>
              <div style={{ padding:12, display:'flex', alignItems:'center', justifyContent:'space-between' }}>
                <strong>{isHebrewUI ? '◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊ó◊ô◊§◊ï◊©◊ô◊ù' : 'Search history'}</strong>
                <button onClick={()=>setMenuOpen(false)} style={{ border:'1px solid #374151', background:'transparent', color:'#e5e7eb', borderRadius:8, padding:'4px 8px', cursor:'pointer' }}>‚úï</button>
              </div>
              <div style={{ padding:'0 12px 12px', display:'flex', gap:8 }}>
                <button onClick={deleteSelected} style={{ border:'1px solid #ef4444', background:'transparent', color:'#fecaca', borderRadius:8, padding:'6px 10px', cursor:'pointer' }}>{isHebrewUI ? '◊û◊ó◊ß ◊†◊ë◊ó◊®◊ô◊ù' : 'Delete selected'}</button>
                <button onClick={clearAll} style={{ border:'1px solid #93c5fd', background:'transparent', color:'#93c5fd', borderRadius:8, padding:'6px 10px', cursor:'pointer' }}>{isHebrewUI ? '◊†◊ß◊î ◊î◊õ◊ú' : 'Clear all'}</button>
              </div>
              <div style={{ padding:'0 8px 12px', overflowY:'auto', height:'calc(100% - 152px)' }}>
                {history.length === 0 && <div style={{ padding:12, color:'#94a3b8' }}>{isHebrewUI ? '◊ê◊ô◊ü ◊î◊ô◊°◊ò◊ï◊®◊ô◊î ◊¢◊ì◊ô◊ô◊ü' : 'No history yet'}</div>}
                {history.map(q => (
                  <div key={q} style={{ display:'flex', alignItems:'center', gap:8, padding:'6px 6px', borderBottom:'1px solid #1f2937' }}>
                    <input type="checkbox" checked={selected.has(q)} onChange={()=>toggleSelect(q)} />
                    <button onClick={()=>reSearch(q)} style={{ textAlign:'start', flex:1, background:'transparent', border:0, color:'#e5e7eb', cursor:'pointer' }}>{q}</button>
                  </div>
                ))}
              </div>

              <div id="dev-credit" style={{ position:'absolute', bottom:12, left:12, right:12, borderTop:'1px solid #1f2937', color:'#93c5fd', fontWeight:600, fontSize:13, padding:'8px 4px', textAlign: isHebrewUI ? 'right' : 'left' }}>
                {isHebrewUI ? '◊§◊ï◊™◊ó ◊¢◊¥◊ô ◊ú◊ô◊®◊ü ◊û◊ô◊õ◊ê◊ú◊ô' : 'Developed by Liran Michaely'}
              </div>

            </aside>

            <main style={{ padding:16, marginInlineStart: menuOpen && !isHebrewUI ? 320 : 0, marginInlineEnd: menuOpen && isHebrewUI ? 320 : 0, transition:'margin .2s ease' }}>
              <div style={{ display:'flex', gap:8, marginBottom:12, flexWrap:'wrap' }}>
                <input
                  placeholder={isHebrewUI ? '◊î◊ß◊ú◊ì ◊†◊ï◊©◊ê‚Ä¶' : 'Enter a topic‚Ä¶'}
                  value={topic}
                  onChange={e=>setTopic(e.target.value)}
                  onKeyDown={e=>{ if (e.key==='Enter') fetchNews(topic); }}
                  style={{ flex:1, padding:'12px 14px', borderRadius:14, border:'1px solid #93c5fd', minWidth:240, fontSize:'1rem', background:'rgba(255,255,255,0.95)' }}
                />
                <button onClick={()=>fetchNews(topic)} disabled={loading || !topic.trim()} style={{ padding:'12px 16px', borderRadius:14, background:loading?'#6b7280':'linear-gradient(135deg, #22c55e, #06b6d4)', color:'#fff', border:'none', fontWeight:700, cursor:loading?'not-allowed':'pointer' }}>{loading ? (isHebrewUI ? '◊ò◊ï◊¢◊ü‚Ä¶' : 'Loading‚Ä¶') : (isHebrewUI ? '◊ó◊§◊©' : 'Search')}</button>
                <button onClick={()=>{ setTopic(''); setArticles([]); setError(null); }} style={{ padding:'12px 16px', borderRadius:14, background:'rgba(17,24,39,0.6)', color:'#e5e7eb', border:'1px solid #93c5fd', cursor:'pointer' }}>{isHebrewUI ? '◊†◊ß◊î' : 'Clear'}</button>
              </div>

              {error && <div style={{ background:'rgba(239,68,68,0.15)', color:'#fecaca', border:'1px solid #ef4444', padding:12, borderRadius:12, marginBottom:12 }}>
                <strong>Error:</strong> {error}
                <br />
                <small style={{ opacity:0.8 }}>{isHebrewUI ? '◊†◊°◊î ◊†◊ï◊©◊ê ◊ê◊ó◊® ◊ê◊ï ◊ó◊õ◊î ◊û◊°◊§◊® ◊ì◊ß◊ï◊™ ◊ï◊†◊°◊î ◊©◊ï◊ë' : 'Try a different topic or wait a few minutes and try again'}</small>
              </div>}

              {!loading && articles.length === 0 && !error && (
                <div style={{ background:'rgba(255,255,255,0.98)', border:'1px solid #e5e7eb', borderRadius:18, padding:20, textAlign:'center' }}>
                  <p style={{ color:'#6b7280' }}>{isHebrewUI ? '◊ó◊§◊© ◊†◊ï◊©◊ê ◊õ◊ì◊ô ◊ú◊®◊ê◊ï◊™ ◊™◊ï◊¶◊ê◊ï◊™.' : 'Search for a topic to see results.'}</p>
                </div>
              )}

              {!loading && articles.length > 0 && (
                <div style={{ display:'grid', gridTemplateColumns:'repeat(auto-fill, minmax(280px, 1fr))', gap:16 }}>
                  {articles.map(a => (
                    <article key={a.id || a.url} style={{ borderRadius:22, overflow:'hidden', boxShadow:'0 10px 24px rgba(0,0,0,0.25)', background:'rgba(255,255,255,0.98)' }}>
                      <button onClick={()=>{
                        // Ensure we always use the most decoded URL possible
                        const finalUrl = decodeGoogleLink(a.url);
                        console.log('üéØ Card clicked - Using URL:', finalUrl);
                        openPreview(finalUrl, a.title, a.source, a.image);
                      }} style={{ display:'block', width:'100%', background:'transparent', border:0, padding:0, cursor:'pointer' }}>
                        {/* Show image immediately if it was fetched from the real article, not a fallback */}
                        {a.image && a.image !== fallbackImgSeed(a.title) && <img src={a.image} alt="" style={{ width:'100%', height:180, objectFit:'cover' }} />}
                        <div style={{ padding:12 }}>
                          <div style={{ display:'flex', justifyContent:'space-between', fontSize:12, color:'#64748b', marginBottom:6 }}>
                            <div style={{ display:'flex', alignItems:'center', gap:4 }}>
                              <span style={{ background:'#eef2ff', color:'#3730a3', borderRadius:999, padding:'2px 8px', fontWeight:600 }}>{a.source}</span>
                            </div>
                            <div style={{ display:'flex', alignItems:'center', gap:4 }}>
                              {a.url !== a.originalUrl && <span style={{ background:'#10b981', color:'white', borderRadius:999, padding:'2px 6px', fontSize:10, fontWeight:600 }}>‚úì Direct</span>}
                              <span>{timeAgo(a.publishedAt)}</span>
                            </div>
                          </div>
                          <h3 style={{ fontSize:18, margin:'2px 0 6px', color:'#111827' }}>{a.enhancedTitle || a.title}</h3>
                          {(a.enhancedDescription || a.description) && <p style={{ fontSize:14, color:'#374151', margin:0 }}>{truncate(a.enhancedDescription || a.description)}</p>}
                        </div>
                      </button>
                    </article>
                  ))}
                </div>
              )}
            </main>

            {preview && (
              <div style={{ position:'fixed', inset:0, background:'rgba(0,0,0,0.55)', display:'grid', placeItems:'center', zIndex:1000 }} onClick={closePreview}>
                <div style={{ width:'92vw', maxWidth:900, background:'#0b1220', borderRadius:16, overflow:'hidden', boxShadow:'0 20px 60px rgba(0,0,0,0.5)' }} onClick={e=>e.stopPropagation()}>
                  <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', padding:'10px 14px', background:'#111827', color:'#e5e7eb', borderBottom:'1px solid #1f2937' }}>
                    <strong style={{ fontSize:14, opacity:.9 }}>{preview.source}</strong>
                    <button onClick={closePreview} style={{ border:'1px solid #374151', background:'transparent', color:'#e5e7eb', borderRadius:8, padding:'6px 10px', cursor:'pointer' }}>‚úï</button>
                  </div>
                  {preview.image && <img src={preview.image} alt="" style={{ width:'100%', maxHeight:360, objectFit:'cover' }} />}
                  <div style={{ padding:16, color:'#e5e7eb' }}>
                    <h2 style={{ margin:'0 0 8px' }}>{preview.title}</h2>
                    {preview.loading && <p style={{ opacity:.8 }}>{isHebrewUI ? '◊ò◊ï◊¢◊ü ◊™◊¶◊ï◊í◊î ◊û◊ß◊ì◊ô◊û◊î‚Ä¶' : 'Loading preview‚Ä¶'}</p>}
                    {!preview.loading && preview.description && <p style={{ opacity:.9 }}>{preview.description}</p>}
                    {!preview.loading && preview.error && <p style={{ opacity:.8, color:'#fecaca' }}>{preview.error}</p>}
                    <div style={{ display:'flex', gap:8, marginTop:12, flexWrap:'wrap' }}>
                      {(() => {
                        // Determine the link to open and copy/share. If the preview URL still
                        // points to Google News, decode it to the underlying article URL.
                        // Always decode the preview URL to ensure it isn't a Google News wrapper
                        const finalUrl = decodeGoogleLink(preview.url);
                        return (
                          <>
                            <a href={finalUrl} target="_blank" rel="noopener noreferrer" style={{ textDecoration:'none', padding:'10px 12px', borderRadius:10, background:'#2563eb', color:'#fff' }}>{isHebrewUI ? '◊§◊™◊ó ◊û◊ß◊ï◊®' : 'Read on site'}</a>
                            <button onClick={()=>navigator.clipboard.writeText(finalUrl)} style={{ padding:'10px 12px', borderRadius:10, border:'1px solid #374151', background:'transparent', color:'#e5e7eb', cursor:'pointer' }}>{isHebrewUI ? '◊î◊¢◊™◊ß ◊ß◊ô◊©◊ï◊®' : 'Copy link'}</button>
                            {"share" in navigator ? (<button onClick={()=>navigator.share({ title: preview.title, url: finalUrl })} style={{ padding:'10px 12px', borderRadius:10, border:'1px solid #374151', background:'transparent', color:'#e5e7eb', cursor:'pointer' }}>{isHebrewUI ? '◊©◊™◊£' : 'Share'}</button>) : null}
                          </>
                        );
                      })()}
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    
// === Multi-source aggregator addition (2025-08-09) ===
const MULTI_SOURCES = [
  // Global / generic
  { name: "Reuters", type:"section", url: ()=>"https://www.reuters.com/rss/world" },
  { name: "AP Top", type:"section", url: ()=>"https://apnews.com/hub/ap-top-news?utm_source=applenews" }, // may not be pure RSS; will be skipped if parse fails

  // Israel - Hebrew
  { name: "Ynet", type:"section", url: ()=>"https://www.ynet.co.il/Integration/StoryRss2.xml" },
  { name: "Walla", type:"section", url: ()=>"https://www.walla.co.il/rss/1" }, // News section
  { name: "Globes", type:"section", url: ()=>"https://www.globes.co.il/webservice/rss/rssfeeder.asmx/FrontPage" },
  // Mako (various sections exist; general news feed)
  { name: "Mako", type:"section", url: ()=>"https://rcs.mako.co.il/rss/news-israel.xml" },

  // Israel - English
  { name: "Times of Israel", type:"section", url: ()=>"https://www.timesofisrael.com/feed/" },
  { name: "Jerusalem Post", type:"section", url: ()=>"https://www.jpost.com/Rss/RssFeedsHeadlines.aspx" },
  { name: "Haaretz EN", type:"section", url: ()=>"https://www.haaretz.com/cmlink/haaretz-com-all-headlines-rss-1.4605102" },
];

async function fetchRSS_AllOrigins(url){
  const proxies = [
    `https://corsproxy.io/?${encodeURIComponent(url)}`,
    `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
    `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
  ];
  
  for (const proxy of proxies) {
    try {
      const r = await fetch(proxy);
      if (!r.ok) continue;
      
      if (proxy.includes('allorigins.win')) {
        const j = await r.json();
        return j.contents || "";
      } else if (proxy.includes('codetabs.com')) {
        const j = await r.json();
        return j.data || "";
      } else {
        return await r.text();
      }
    } catch (e) {
      continue;
    }
  }
  
  throw new Error("All proxies failed");
}

function parseRssItems(xmlText){
  const xml = new DOMParser().parseFromString(xmlText, "text/xml");
  const items = Array.from(xml.querySelectorAll("item, entry")).map((node)=>{
    const get = (sel)=> node.querySelector(sel)?.textContent?.trim() || "";
    const title = get("title");
    const link = get("link") || node.querySelector("link")?.getAttribute("href") || "";
    const pubDate = get("pubDate") || get("updated") || get("published");
    const description = get("description") || get("summary") || "";
    const media = node.querySelector("media\\:content, content, enclosure");
    const image = media?.getAttribute("url") || "";
    return { title, link, publishedAt: pubDate ? new Date(pubDate).toISOString() : null, description, image };
  });
  return items;
}

async function searchAcrossSources(query){
  const qVars = expandHebrewVariants(query);
  const terms = new Set([query, ...qVars]);
  const attempted = MULTI_SOURCES.length;
  let succeeded = 0;

  const tasks = MULTI_SOURCES.map(async (src)=>{
    try{
      const url = src.type === "search" ? src.url(query) : src.url();
      const xml = await fetchRSS_AllOrigins(url);
      const items = parseRssItems(xml).filter(it=>{
        // Filter by any term match in title or description (case-insensitive, supports Hebrew)
        const hay = (it.title + " " + it.description).toLowerCase();
        for (const t of terms){
          if (t && hay.includes(String(t).toLowerCase())) return true;
        }
        return terms.size === 0; // fallback
      }).slice(0, 20).map(it=>({ ...it, source: src.name }));
      succeeded++;
      return items;
    } catch(e){
      return [];
    }
  });

  const results = (await Promise.all(tasks)).flat();
  setScanInfo({attempted, succeeded});
  return results;
}

// Hook our search UI (non-breaking): if a global searchNews function exists, replace it.
window.__multiSourceEnabled = true;
</script>
    <script>
      // Mobile error surface to avoid silent white screens
      window.addEventListener('error', function(e){
        const el = document.createElement('div');
        el.style = 'position:fixed;bottom:0;left:0;right:0;background:#111827;color:#fecaca;font:12px/1.4 system-ui;padding:8px;z-index:9999;border-top:1px solid #ef4444';
        el.textContent = 'Error: ' + (e && e.message ? e.message : 'unknown');
        document.body.appendChild(el);
      });
    </script>
  
    <script>
    (function(){
      function isHebrewUI(){
        var inp = document.querySelector('input[placeholder]');
        if(!inp) return false;
        var ph = inp.getAttribute('placeholder') || '';
        var val = inp.value || '';
        return /[\u0590-\u05FF]/.test(ph) || /[\u0590-\u05FF]/.test(val);
      }
      function ensureCredit(){
        var aside = document.querySelector('aside');
        if(!aside) return;
        var el = aside.querySelector('#dev-credit');
        if(!el){
          el = document.createElement('div');
          el.id = 'dev-credit';
          el.style.cssText = 'padding:12px;border-top:1px solid #1f2937;color:#93c5fd;font-weight:600;font-size:13px';
          aside.appendChild(el);
        }
        el.textContent = isHebrewUI() ? '◊§◊ï◊™◊ó ◊¢◊¥◊ô ◊ú◊ô◊®◊ü ◊û◊ô◊õ◊ê◊ú◊ô' : 'Developed by Liran Michaely';
      }
      var iv = setInterval(ensureCredit, 500);
      window.addEventListener('beforeunload', function(){ try{ clearInterval(iv); }catch(e){} });
    })();
    </script>

  </body>
</html>
